import os
import pandas as pd
import plotly.express as px
import matplotlib
import matplotlib.pyplot as plt
%matplotlib inline
#reading CSV file
#read file accordingly
data_dir = 'c:\\Users\\Acer\\Downloads'
files = os.listdir(data_dir)
# Path to the CSV file
train_csv = os.path.join(data_dir, 'weatherAUS.csv')
# Load the CSV file into a pandas DataFrame
df = pd.read_csv(train_csv)
print(df.head())
#printing dates of weather conditions
print(df['Date'])
#dropping empty cells
df.dropna(subset=['RainToday', 'RainTomorrow'], inplace=True)
df.info()
#ploting graph of location basis
px.histogram(df, x='Location', title='Location vs. Rainy Days', color='RainToday')
px.histogram(df, x='WindGustSpeed', title='Location vs. Rainy Days', color='RainToday')
px.scatter(df.sample(2000), 
           title='Temp (3 pm) vs. Humidity (3 pm)',
           x='Temp3pm',
           y='Humidity3pm',
           color='RainTomorrow')

#spliting training test and validation inputs for years
year = pd.to_datetime(df.Date).dt.year

train_df = df[year < 2015]
val_df = df[year == 2015]
test_df = df[year > 2015]

#removed date column
input_cols = list(train_df.columns)[1:-1]
target_col = 'RainTomorrow'
print(input_cols)

#coping to new variable to avoid Id column
train_inputs = val_df[input_cols].copy()
train_targets = val_df[target_col].copy()

val_inputs = val_df[input_cols].copy()
val_targets = val_df[target_col].copy()


test_inputs = test_df[input_cols].copy()
test_targets = test_df[target_col].copy()

#spliting of basis of number and categorical data

import numpy as np
numeric_cols = train_inputs.select_dtypes(include=np.number).columns.tolist()
categorical_cols = train_inputs.select_dtypes('object').columns.tolist()

numeric_cols
categorical_cols
train_inputs[numeric_cols].describe()
train_inputs[categorical_cols].nunique()

#handling missing data with simpleImputer
from sklearn.impute import SimpleImputer
imputer = SimpleImputer(strategy = 'mean')
print(imputer)

df[numeric_cols].isna().sum()
train_inputs[numeric_cols].isna().sum()
test_inputs[numeric_cols].isna().sum()
val_inputs[numeric_cols].isna().sum()

imputer.fit(df[numeric_cols])
train_inputs[numeric_cols] = imputer.transform(train_inputs[numeric_cols])
val_inputs[numeric_cols] = imputer.transform(val_inputs[numeric_cols])
test_inputs[numeric_cols] = imputer.transform(test_inputs[numeric_cols])


#featuring value between 0 to 1  
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
scaler.fit(df[numeric_cols])
print('Minimum:')#minimum will be 0
list(scaler.data_min_)
print('Maximum')#max will be 1
list(scaler.data_max_)

train_inputs[numeric_cols] = scaler.transform(train_inputs[numeric_cols])
val_inputs[numeric_cols] = scaler.transform(val_inputs[numeric_cols])
test_inputs[numeric_cols] = scaler.transform(test_inputs[numeric_cols])

#changing catagorical data to numeric
from sklearn.preprocessing import OneHotEncoder
encoder = OneHotEncoder(sparse_output=False, handle_unknown='ignore')
encoder.fit(df[categorical_cols])
df[categorical_cols]
encoder.categories_
encoded_cols = list(encoder.get_feature_names_out(categorical_cols))
print(encoded_cols)
train_inputs[encoded_cols] = encoder.transform(train_inputs[categorical_cols])
val_inputs[encoded_cols] = encoder.transform(val_inputs[categorical_cols])
test_inputs[encoded_cols] = encoder.transform(test_inputs[categorical_cols])



#train_inputs.to_parquet('train_inputs.parquet')
#val_inputs.to_parquet('val_inputs.parquet')
#test_inputs.to_parquet('test_inputs.parquet')
#pd.DataFrame(train_targets).to_parquet('train_targets.parquet')
#pd.DataFrame(val_targets).to_parquet('val_targets.parquet')
#pd.DataFrame(test_targets).to_parquet('test_targets.parquet')
#train_inputs = pd.read_parquet('train_inputs.parquet')
#val_inputs = pd.read_parquet('val_inputs.parquet')
#test_inputs = pd.read_parquet('test_inputs.parquet')
#train_targets = pd.read_parquet('train_targets.parquet')[target_col]
#val_targets = pd.read_parquet('val_targets.parquet')[target_col]
#test_targets = pd.read_parquet('test_targets.parquet')[target_col]



print('train_inputs:', train_inputs.shape)
print('train_targets:', train_targets.shape)
print('val_inputs:', val_inputs.shape)
print('val_targets:', val_targets.shape)
print('test_inputs:', test_inputs.shape)
print('test_targets:', test_targets.shape)


#Applying logistic Regression
from sklearn.linear_model import LogisticRegression
model = LogisticRegression(solver='liblinear')
model.fit(train_inputs[numeric_cols + encoded_cols], train_targets)
print(numeric_cols + encoded_cols)

print(model.coef_.tolist())

X_train = train_inputs[numeric_cols + encoded_cols]
X_val = val_inputs[numeric_cols + encoded_cols]
X_test = test_inputs[numeric_cols + encoded_cols]

train_preds = model.predict(X_train)

train_preds

train_targets

#comparing probablity with training predicted and target data
train_probs = model.predict_proba(X_train)
train_probs

#checking accuracy
from sklearn.metrics import accuracy_score
accuracy_score(train_targets, train_preds)


from sklearn.metrics import confusion_matrix
confusion_matrix(train_targets, train_preds, normalize='true')

#changing Raw input to readable form to model.
def predict_input(single_input):
    input_df = pd.DataFrame([single_input])
    input_df[numeric_cols] = imputer.transform(input_df[numeric_cols])
    input_df[numeric_cols] = scaler.transform(input_df[numeric_cols])
    input_df[encoded_cols] = encoder.transform(input_df[categorical_cols])
    X_input = input_df[numeric_cols + encoded_cols]
    pred = model.predict(X_input)[0]
    prob = model.predict_proba(X_input)[0][list(model.classes_).index(pred)]
    return pred, prob

new_input = {'Date': '2021-06-19',
             'Location': 'Launceston',
             'MinTemp': 23.2,
             'MaxTemp': 33.2,
             'Rainfall': 10.2,
             'Evaporation': 4.2,
             'Sunshine': np.nan,
             'WindGustDir': 'NNW',
             'WindGustSpeed': 52.0,
             'WindDir9am': 'NW',
             'WindDir3pm': 'NNE',
             'WindSpeed9am': 13.0,
             'WindSpeed3pm': 20.0,
             'Humidity9am': 89.0,
             'Humidity3pm': 58.0,
             'Pressure9am': 1004.8,
             'Pressure3pm': 1001.5,
             'Cloud9am': 8.0,
             'Cloud3pm': 5.0,
             'Temp9am': 25.7,
             'Temp3pm': 33.0,
             'RainToday': 'Yes'}

predict_input(new_input)
